### ❗️모두 [엔지니어대한민국](https://youtube.com/user/damazzang)님의 영상을 보고 정리한 내용입니다. 
<hr>
<br/>

# [Linked List의 개념](https://youtu.be/DzGnME1jIwY)
**Linked List란?** 컴퓨에 자료를 저장하는 구조 중 하나로, 일렬로 연결된 데이터를 저장할 때 사용된다. 길이가 정해저 있지 않은 데이터의 연결된 집합이다. 데이터를 저장할 수 있는 공간이 있으면 그 안에 다음에 올 데이터의 주소를 가지고 있다.<br/>
**데이터의 삽입과 삭제.** 중간에 데이터를 삽입하고 싶다면 앞에 가지고 있던 데이터 주소를 자신이 갖고 뒤의 노드에 자신의 데이터 주소를 알려준다. 반대로 삭제하고 싶을 땐 얖의 데이터 주소를 뒤에게 주고 자신은 빠지면 됨. 자신(노드)는 linked list에서 삭제 되었지만 사실 메모리를 잡아먹고 있음
**속도** 일일이 데이터를 찾아다녀야 하기 때문에 속도가 배열보다 느릴 수 있다. 

> 🤚 (비교하기) **Array**란? <br/>
> 배열방들이 물리적으로 한 곳에 모여 있어 배열방의 크기를 한 번 정하면 방 크기를 늘이거나 줄일 수 없다.
> 노드를 추가 삭제하려면 배열방을 통채로 다시 선언해서 복사하고 추가해야하기 때문에 길이가 정해지지 않은 데이터 핸들링에는 적합하지 않다.

| 비교 | **Linked List** | **Array** |
|---|:---:|---|
| 속도 | array보다 느릴 수 있음 | Linked List보다 빠를 수 있음 |
| 쓰임 | 길이가 정해지지 않은 데이터 핸들링시 | 길이가 정해진 데이터 핸들링시 |


# [단/양방향 Linked List 개념](https://youtu.be/G4IIDyfoHeY)
## 단방향 Linked List
데이터를 저장한 노드가 다음 노드의 주소를 가지고 있는 형태이다. 한 방향으로만 이동할 수 있어 검색할 때 가장 앞에 있는 노드부터 하나씩 이동하며 검색해야한다. 한쪽으로만 가기 때문에 헤더 주소 하나만 포인터로 저장한다. 
## 양방향 Linked List
다음에 올 노드와 앞의 노드 주소를 가지고 있다. 양쪽 끝에 포인터를 저장하고 있다. 맨 끝에 노드를 삽입할 때 맨 끝까지 찾아가는 번거로움을 줄일 수 있다. 하지만 공간의 효율이 중요하기 때문에 굳이 양쪽으로 다닐 필요가 없는 데이터 구조를 양방향으로 디자인할 필요는 없다. <br/>
**삽입.** 노드를 생성한다. > `다음노드`의 주소를 `새노드`가 갖는다. > `전노드`는 자신의 주소를 `새노드`에게 준다. `새노드`는 자신의 주소를 `다음노드`에게 준다 > `새노드`는 자신의 주소를 `전노드`에게 준다.<br/>
**삭제.** `삭제할노드`가 가지고 있는 `다음노드` 주소를 `전노드`에게 준다. `전노드`의 주소가 `다음노드`의 주소를 가리키고 있게 한다. <br/>

| 비교 | 단방향 | 양방향 |
|---|:---:|---|
| 가지고 있는 노드 주소 위치 | `다음노드` | `전노드` `다음노드` |
| 포인터 | 앞노드 | 양끝 노드 |

# [Hash Tabel에 대해 알아보고 구현하기](https://youtu.be/Vi0hauJemxA)
**Hash Tabel이란?** 검색하고자 하는 key값을 입력 받아서 hash 함수를 돌려서 반환받은 Hacsh Code를 배열에 Index로 환산을 해서 데이터에 접근하는 방식의 자료구조이다. <br/>
<br/>
**순서** </br>
1. F(key) -> 2. HashCode -> 3. Index -> 4. Value <br/>
### F(key): 
key값은 문자열, 숫자, 파일 데이터도 될 수 있다. Hash 함수는 특정한 규칙을 이용해서 입력 받은 key값으로 key값이 얼마나 큰지에 상관없이 동일 HashCode를 만들어준다. <br/>
### Hash Code
hash code는 정수이기 때문에 검색 속도가 매우 빠르다. 배열 공간을 고정된 크기만큼 미리 만들어 놓고 hash code를 배열의 개수로 나머지 연산(`%`)을 해서 배열에 나눠 담는 것이다. 그 말은 즉, 해쉬코드 자체가 배열 방의 인덱스로 사용되기 때문에 검색 자체를 할 필요 없고 해쉬코드로 바로 데이터의 위치에 다이렉트로 접근할 수 있어 빠르다. <br/>
<br/>
(일례로 암호 화폐가 있다. 암호 화폐의 핵심 기술인 블록 체인에서 각 사용자들의 공공장부를 비교할 때 hash code를 이용한다. 블록 체인은 10분 간격으로 성사된 거래기록을 블록체인 창고에 저장하고 지금까지 일어난 모든 블록체인 거래 기록을 그 서비스를 이용하는 모든 사용자들이 전자 지갑에 갖고 있게 하는 기술이다. 성사된 거래기록을 블록체인 창고에 저장하고 지금까지 일어난 모든 블록체인 거래 기록을 그 서비스를  모든 사람들의 모든 거래 기록을 모든 사용자들이 갖고 있는 것이다. 원본 장부를 비교할 하려면 엄청나게 시간이 오래 걸리므로 장부를 hash code로 바꿔 hash code만 비교해 거래할 수 있도록 하면 개인정보 측면과 속도 측면에서 모두 좋다. 입력데이터가 완벽하게 일치해야 동일한 hash code를 만들어 내 거래내역이 조금이라도 다르면 전혀 다른 hash code를 만들어낸다.) <br/>
<br/>
hash code의 고민: 해쉬 코드를 배열에 나눠야 하는데 한쪽에만 몰릴 수 있다. 따라서 배열방에 골고루 배분할 수 있도록 알고리즘을 잘 만들어야 한다. 그것이 바로 Hash Algorithon. 알고리즘이 좋지 않을 때 한 방에 데이터가 여러개 들어가 충돌 현상이 생기는데 이를 collison이 일어난다고 한다. 방안에 들어간 많은 데이터 중 하나를 찾으려면 일일이 검색을 해서 찾아야 한다. 따라서 해쉬코드를 방에 얼마나 잘 분배하는지에 따라 얼마나 좋은 알고리즘인지 결정된다. 
> Hash Algorithon & Collision
> - different keys -> same code : hash algorithon은 다른 키값으로 동일한 코드를 만들어 낼 수 있다. 그 이유는 key값은 문자열이고 그 가지의 수가 무한한데 hash code는 정 > 수개만큼 밖에 제공을 못하기 때문에 알고리즘이 아무리 좋아도 어떤 키들은 중복되는 알고리즘을 가질 수 밖에 없다. 
> - different code -> same index : hash algorithon이 서로 다른 해쉬코드를 만들어 냈는데 배열방이 한정되어 있으니 같은 방에 배정받는 경우가 있다. <br/>
> => (두 경우가 어떠하든) 하나의 배열방에 겹처서 배정되는 것을 모두 collision이라고 부른다. 충돌을 적게 하기 위해 좋은 알고리즘을 만드는게 Hash Tabel에서 중요한 이슈다. 
4:45



